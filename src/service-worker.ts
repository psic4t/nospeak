/// <reference lib="webworker" />

import { cleanupOutdatedCaches, precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { registerRoute, NavigationRoute } from 'workbox-routing';

type PrecacheManifestEntry = {
    url: string;
    revision?: string;
};

declare let self: ServiceWorkerGlobalScope & {
    __WB_MANIFEST: Array<PrecacheManifestEntry | string> | undefined;
};

// Take control of clients when activated
// Note: skipWaiting removed to allow proper cache warm-up before activation
clientsClaim();

// Support "prompt" update flow from virtual:pwa-register.
// registerSW() will postMessage({ type: 'SKIP_WAITING' }) when user accepts update.
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        void self.skipWaiting();
    }
});

// Clean up old caches
cleanupOutdatedCaches();

// Precache assets generated by Vite
// If the manifest injection fails for any reason, avoid crashing.
const wbManifest = self.__WB_MANIFEST;

// IMPORTANT: The app shell must be revisioned so it stays in sync with hashed _app assets.
// Workbox's createHandlerBoundToURL('index.html') requires index.html to be precached.
// Some toolchains exclude index.html from __WB_MANIFEST, so we ensure it is present
// with a build-changing revision derived from _app/version.json.
const manifest = Array.isArray(wbManifest) ? wbManifest : [];

const normalizeUrl = (url: string): string => url.startsWith('/') ? url.slice(1) : url;

const versionEntry = manifest.find((entry) => {
    if (typeof entry === 'string') {
        return normalizeUrl(entry) === '_app/version.json';
    }
    return normalizeUrl(entry.url) === '_app/version.json';
});

const versionRevision = typeof versionEntry === 'string' ? undefined : versionEntry?.revision;

const hasIndexHtml = manifest.some((entry) => {
    const url = typeof entry === 'string' ? entry : entry.url;
    const normalized = normalizeUrl(url);
    return normalized === 'index.html';
});

if (!hasIndexHtml) {
    manifest.push({
        url: 'index.html',
        revision: versionRevision ?? String(Date.now())
    });
}

precacheAndRoute(manifest);

// Handle all navigation requests by serving index.html
// This enables client-side routing to work for all routes (/chat, /contacts, etc.)
const handler = createHandlerBoundToURL('index.html');
registerRoute(new NavigationRoute(handler));

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
    event.notification.close();

    const urlToOpen = event.notification.data?.url;

    if (!urlToOpen) return;

    const promiseChain = self.clients.matchAll({
        type: 'window',
        includeUncontrolled: true
    }).then((windowClients) => {
        // Check if there is already a window/tab open with the target URL
        let matchingClient: WindowClient | null = null;

        for (const client of windowClients) {
            const clientUrl = new URL(client.url);
            const targetUrl = new URL(urlToOpen, self.location.origin);
            
            // Check if it's the same origin and path
            if (clientUrl.origin === targetUrl.origin) {
                matchingClient = client;
                // If it's the exact same page, we're done searching
                if (clientUrl.pathname === targetUrl.pathname) {
                    break;
                }
            }
        }

        if (matchingClient) {
            // Focus the existing window
            return matchingClient.focus().then(() => {
                // Navigate to the specific chat if needed
                if (matchingClient.url !== urlToOpen) {
                    return matchingClient.navigate(urlToOpen);
                }
            });
        } else {
            // If no window is open, open a new one
            return self.clients.openWindow(urlToOpen);
        }
    });

    event.waitUntil(promiseChain);
});
